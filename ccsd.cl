;;;;
;;;; File: ccd.cl
;;;; Author
;;;; Description:
;;;;    experiment code

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; when compile with sbcl.cl -c, uncomment these lines
;(eval-when (:compile-toplevel :load-toplevel :execute)
;  (load "utility.fasl"))
(load "utility.cl")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun attach-tag (tag x)
  (cons tag x))
(defmacro tag-of (x)
  `(car ,x))
(defmacro content-of (x)
  `(cdr ,x))
;;; commutator : p q^\dagger + q^\dagger p = \delta_{pq}

;;; type:
;;; h+   ->-|   '(+ ? ?)
;;; p+   -<-|   '(? + ?)
;;; h-   |->-   '(- ? ?)
;;; p-   |-<-   '(? - ?)
;;; kr   Kronecker delta
;;;
;;; (t_{ijk}^{abc} (i a 1) (j b 2) (k c 3))

(defun make-pair-op (hole particle ind)
  (list hole particle ind))
(defun hole-of (a)
  (car a))
(defun particle-of (a)
  (cadr a))
(defun index-of (a)
  (caddr a))
(defun op-w/o-index (a)
  (list (hole-of a) (particle-of a)))

(defun amplitude? (a)
  (eql (tag-of a) 't))
;(defun amplitudes? (a)
;  (every #'amplitude? a))
(defun h2e? (a)
  (eql (tag-of a) 'g))

;;; if (func lst) return single result
(defun mapreplace (func lst)
  (if (null lst)
      '()
      (let* ((item1 (car lst))
             (item-rest (cdr lst))
             (res1 (funcall func item1))
             (res-rest (mapcar (lambda (a) (cons item1 a))
                               (mapreplace func item-rest))))
        (if (null res1)
            res-rest
            (cons (cons res1 item-rest)
                  res-rest)))))
;;; in case (func lst) return a list of results, flatten the return results
(defun mapreplace* (func lst)
  (if (null lst)
      '()
      (let* ((item1 (car lst))
             (item-rest (cdr lst))
             (res1 (funcall func item1))
             (res-rest (mapcar (lambda (a) (cons item1 a))
                               (mapreplace* func item-rest))))
        (if (null res1)
            res-rest
            (append (mapcar (lambda (a) (cons a item-rest)) res1)
                    res-rest)))))

(defun sort-pair-ops (ops)
  (sort ops (lambda (op1 op2)
              (< (index-of op1) (index-of op2)))))
;;; all possible contraction of one hole and an amplitude
;; return the sum of a list of amp
;; save last status, to avoid double counting of symmetric amplitudes
(defun contract-hole-amp (hole-ind amp)
  (let ((last-pair '()))
    (flet ((commute (pair-op)
             (let ((this-pair (op-w/o-index pair-op)))
               (unless (or (numberp (hole-of pair-op))
                           (equal last-pair this-pair))
                 (setq last-pair this-pair)
                 (make-pair-op hole-ind
                               (particle-of pair-op)
                               (index-of pair-op))))))
      (mapcar (lambda (ops)
                (attach-tag 't ops))
              (mapreplace #'commute (content-of amp))))))
(defun contract-particle-amp (particle-ind amp)
  (let ((last-pair '()))
    (flet ((commute (pair-op)
             (let ((this-pair (op-w/o-index pair-op)))
               (unless (or (numberp (particle-of pair-op))
                           (equal last-pair this-pair))
                 (setq last-pair this-pair)
                 (make-pair-op (hole-of pair-op)
                               particle-ind
                               (index-of pair-op))))))
      (mapcar (lambda (ops)
                (attach-tag 't ops))
              (mapreplace #'commute (content-of amp))))))
; return the sum of a list of ampprod
(defun amp-w/o-index (amp)
  (mapcar #'op-w/o-index (content-of amp)))
(defun contract-hole-ampprod (hole-ind ampprod)
  (let ((last-amp '()))
    (mapreplace* (lambda (amp)
                   (let ((this-amp (amp-w/o-index amp)))
                     (unless (equal last-amp this-amp)
                       (setq last-amp this-amp)
                       (contract-hole-amp hole-ind amp))))
                 ampprod)))
(defun contract-particle-ampprod (particle-ind ampprod)
  (let ((last-amp '()))
    (mapreplace* (lambda (amp)
                   (let ((this-amp (amp-w/o-index amp)))
                     (unless (equal last-amp this-amp)
                       (setq last-amp this-amp)
                       (contract-particle-amp particle-ind amp))))
                 ampprod)))
    
; return a list of amplitudes
(defun contract-ops-ampprods (pair-ops ampprod-lst)
  (flet ((link-h (pair-op ampprod)
           (if (eql (hole-of pair-op) '-)
               (contract-hole-ampprod (index-of pair-op) ampprod)
               (list ampprod)))
         (link-p (pair-op ampprod)
           (if (eql (particle-of pair-op) '-)
               (contract-particle-ampprod (index-of pair-op) ampprod)
               (list ampprod)))
         (contract-iter (func pair-ops ampprod-lst)
           (reduce (lambda (ts-lst pair-op)
                     (mapcan (lambda (ampprod) (funcall func pair-op ampprod))
                             ts-lst))
                   pair-ops :initial-value ampprod-lst)))
    (contract-iter #'link-p pair-ops
                   (contract-iter #'link-h pair-ops ampprod-lst))))
(defun contract-h2e-ampprod (h2e ampprod)
  (contract-ops-ampprods (content-of h2e) (list ampprod)))

; if the 2e-operator is symmetric, remove those duplicated amplitude products
(defun contract-symm-h2e-ampprod (filter h2e ampprod)
  (let ((ampprod-lst (contract-h2e-ampprod h2e ampprod)))
    (remove-if-not filter ampprod-lst)))
(defun ordering-h2e-symm-hole (ampprod)
  (flet ((get-hole-index (amp)
           (mapcan (lambda (pair-op)
                     (let ((hole-idx (hole-of pair-op)))
                       (and (numberp hole-idx) (list hole-idx))))
                   (content-of amp))))
    (format t "~a~%" (mapcan #'get-hole-index ampprod))
    (apply #'< (mapcan #'get-hole-index ampprod))))

(defun ordering-h2e-symm-particle (ampprod)
  (flet ((get-hole-index (amp)
           (mapcan (lambda (pair-op)
                     (let ((particle-idx (particle-of pair-op)))
                       (and (numberp particle-idx) (list particle-idx))))
                   (content-of amp))))
    (apply #'< (mapcan #'get-hole-index ampprod))))

(defun id-pair-op (pair-op &optional (oplist '(1 2 +)))
  (let ((shift (length oplist))
        (h-id (position (hole-of pair-op) oplist))
        (p-id (position (particle-of pair-op) oplist)))
    (+ (* shift h-id) p-id)))

; id of amplitude in terms of id-pair-op
(defun id-amp (amp &optional (oplist '(1 2 +)))
  (sort (mapcar (lambda (x) (id-pair-op x oplist))
                (content-of amp))
        #'<))

(defun list-lt (l1 l2)
  (cond ((null l1) t)
        ((null l2) nil)
        ((eq (car l1) (car l2))
         (list-lt (cdr l1) (cdr l2)))
        (t (< (car l1) (car l2)))))
(defun id-ampprod (ampprod &optional (oplist '(1 2 +)))
  (sort (mapcar (lambda (x) (id-amp x oplist)) ampprod)
        (lambda (x y)
          (let ((len-x (length x))
                (len-y (length y)))
            (if (eq len-x len-y)
                (list-lt x y)
                (< len-x len-y))))))


(defun remove-h2e-symm-dup (ampprod-lst oplist)
  (flet ((ampprod-eql (ts1 ts2)
           (let ((swaplist `(,(second oplist) ,(first oplist) ,@(cddr oplist))))
             (equal (id-ampprod ts1 oplist)
                    (id-ampprod ts2 swaplist)))))
    (remove-duplicates ampprod-lst :test #'ampprod-eql :from-end t)))



(defun connected-amp? (amp)
  (notevery (lambda (pair-op)
              (and (eql (hole-of pair-op) '+)
                   (eql (particle-of pair-op) '+)))
            (content-of amp)))
(defun connected-ampprod? (ampprod)
  (every #'connected-amp? ampprod))
(defun remove-unconnected (ampprod-lst)
  (remove-if-not #'connected-ampprod? ampprod-lst))


(defmacro pass? (test value)
  `(format t "~a  ~:[FAIL~;pass~]~%" ',test (equal ,test ,value)))

(pass? (amplitude? '(t)) t)
;(pass? (amplitudes? '((t) (t))) t)
;(pass? (amplitudes? '((v) (t))) nil)

(pass? (mapreplace #'evenp '(1 2 3))
       '((1 t 3)))
(pass? (mapreplace #'evenp '(1 1 3))
       '())
(pass? (mapreplace* (lambda (x) (mapreplace #'evenp x)) '((1) (2 3)))
       '((1) (t 3)))
(pass? (mapreplace* (lambda (x) (mapreplace #'evenp x)) '((1) (2) (3)))
       '((1) (t) (3)))

(pass? (sort-pair-ops '((a a 3) (b b 1) (c c 4) (d d 2)))
       '((B B 1) (D D 2) (A A 3) (C C 4)))



; contract with a t3 amplitude
(pass? (contract-hole-amp 9 '(t (h+ p 1) (h+ p 2) (4 p 3)))
       '((t (9 p 1) (h+ p 2) (4 p 3))))
(pass? (contract-particle-amp 9 '(t (h p 1) (h 4 2) (5 p 3)))
       '((t (h 9 1) (h 4 2) (5 p 3))
         (t (h p 1) (h 4 2) (5 9 3))))
(pass? (contract-particle-amp 9 '(t (h 4 1)))
       nil)
(pass? (contract-hole-amps 9 '((t (h+ p 1)) (t (4 p 2) (h+ p 3))))
       '(((t (9 p 1)) (t (4 p 2) (h+ p 3)))
         ((t (h+ p 1)) (t (4 p 2) (9 p 3)))))
(pass? (contract-particle-amps 9 '((t (h+ p+ 1)) (t (h+ p+ 2))))
       '(((t (h+ 9 1)) (t (h+ p+ 2)))))
(pass? (contract-ops-ampprods '((- + 8) (- + 9)) '(((t (h p 1) (h p 2) (h p 3)))))
       '((t (8 p 1) (9 p 2) (h p 3))))
(pass? (contract-particle-amps 8 '((t (8 p 1) (9 p 2) (h p 3))))
       '(((t (8 8 1) (9 p 2) (h p 3)))
         ((t (8 p 1) (9 8 2) (h p 3)))
         ((t (8 p 1) (9 p 2) (h 8 3)))))
(pass? (contract-ops-ampprods '((+ - 9))
                              '(((t (8 8 1) (9 p 2) (h p 3)))
                                ((t (8 p 1) (9 8 2) (h p 3)))
                                ((t (8 p 1) (9 p 2) (h 8 3)))))
       '(((t (8 8 1) (9 9 2) (h p 3)))
         ((t (8 8 1) (9 p 2) (h 9 3)))
         ((t (8 9 1) (9 8 2) (h p 3)))
         ((t (8 p 1) (9 8 2) (h 9 3)))
         ((t (8 9 1) (9 p 2) (h 8 3)))
         ((t (8 p 1) (9 9 2) (h 8 3)))))
(pass? (contract-h2e-ampprod '(g (- - 8) (- - 9))
                             '((t (h p 1) (h p 2) (h p 3))))
       '(((t (8 8 1) (9 9 2) (h p 3)))
         ((t (8 8 1) (9 p 2) (h 9 3)))
         ((t (8 9 1) (9 8 2) (h p 3)))
         ((t (8 p 1) (9 8 2) (h 9 3)))
         ((t (8 9 1) (h 8 2) (9 p 3)))
         ((t (8 p 1) (h 8 2) (9 9 3)))))

(pass? (contract-h2e-ampprod '(g (- - 8) (- - 9)) '((t (h p 1))))
       '())
(pass? (contract-h2e-ampprod '(g (- - 8) (- + 9))
                             '((t (h p 1)) (t (h p 2))))
       '(((t (8 8 1)) (t (9 p 2)))
         ((t (8 p 1)) (t (9 8 2)))))
(pass? (contract-h2e-ampprod '(g (+ - 8) (- + 9))
                             '((t (h p 1) (h p 2))))
       '(((t (9 8 1) (h p 2)))
         ((t (9 p 1) (h 8 2)))))
(pass? (contract-symm-h2e-ampprod #'ordering-h2e-symm-hole
                                  '(g (- + 8) (- + 9))
                                  '((t (h p 1)) (t (h p 3) (h p 4))))
       '(((t (8 p 1)) (t (9 p 3) (h p 4)))
         ((t (h p 1)) (t (8 p 3) (9 p 4)))))
(pass? (contract-h2e-ampprod '(g (- - 8) (- - 9))
                             '((t (h p 1)) (t (h p 3) (h p 4))))
       '(((t (8 8 1)) (t (9 9 3) (h p 4))) ((t (8 8 1)) (t (9 p 3) (h 9 4)))
         ((t (8 9 1)) (t (9 8 3) (h p 4))) ((t (8 p 1)) (t (9 8 3) (h 9 4)))
         ((t (8 9 1)) (t (9 p 3) (h 8 4))) ((t (8 p 1)) (t (9 9 3) (h 8 4)))
         ((t (9 8 1)) (t (8 9 3) (h p 4))) ((t (9 8 1)) (t (8 p 3) (h 9 4)))
         ((t (9 9 1)) (t (8 8 3) (h p 4))) ((t (9 p 1)) (t (8 8 3) (h 9 4)))
         ((t (9 9 1)) (t (8 p 3) (h 8 4))) ((t (9 p 1)) (t (8 9 3) (h 8 4)))
         ((t (h 8 1)) (t (8 9 3) (9 p 4))) ((t (h 8 1)) (t (8 p 3) (9 9 4)))
         ((t (h 9 1)) (t (8 8 3) (9 p 4))) ((t (h p 1)) (t (8 8 3) (9 9 4)))
         ((t (h 9 1)) (t (8 p 3) (9 8 4))) ((t (h p 1)) (t (8 9 3) (9 8 4)))))
(pass? (contract-symm-h2e-ampprod #'ordering-h2e-symm-hole
                                  '(g (- - 8) (- - 9))
                                  '((t (h p 1)) (t (h p 3) (h p 4))))
       '(((t (8 8 1)) (t (9 9 3) (h p 4)))
         ((t (8 8 1)) (t (9 p 3) (h 9 4)))
         ((t (8 9 1)) (t (9 8 3) (h p 4)))
         ((t (8 p 1)) (t (9 8 3) (h 9 4)))
         ((t (8 9 1)) (t (9 p 3) (h 8 4)))
         ((t (8 p 1)) (t (9 9 3) (h 8 4)))
         ((t (h 8 1)) (t (8 9 3) (9 p 4)))
         ((t (h 8 1)) (t (8 p 3) (9 9 4)))
         ((t (h 9 1)) (t (8 8 3) (9 p 4)))
         ((t (h p 1)) (t (8 8 3) (9 9 4)))
         ((t (h 9 1)) (t (8 p 3) (9 8 4)))
         ((t (h p 1)) (t (8 9 3) (9 8 4)))))
(pass? (contract-h2e-ampprod '(g (- - 8) (- - 9))
                             '((t (h p 1)) (t (h p 2))))
       '(((t (8 8 1)) (t (9 9 2))) ((t (8 9 1)) (t (9 8 2)))))
(pass? (contract-h2e-ampprod '(g (- - 8) (- + 9))
                             '((t (h p 1) (h p 2)) (t (h p 3) (h p 4))))
       '(((t (8 8 1) (9 p 2)) (t (h p 3) (h p 4)))
         ((t (8 p 1) (9 8 2)) (t (h p 3) (h p 4)))
         ((t (8 p 1) (9 p 2)) (t (h 8 3) (h p 4)))
         ((t (8 8 1) (h p 2)) (t (9 p 3) (h p 4)))
         ((t (8 p 1) (h 8 2)) (t (9 p 3) (h p 4)))
         ((t (8 p 1) (h p 2)) (t (9 8 3) (h p 4)))
         ((t (8 p 1) (h p 2)) (t (9 p 3) (h 8 4)))))
(pass? (contract-h2e-ampprod '(g (- - 8) (- - 9))
                             '((t (h p 1) (h p 2)) (t (h p 3) (h p 4))))
       '(((t (8 8 1) (9 9 2)) (t (h p 3) (h p 4)))
         ((t (8 8 1) (9 p 2)) (t (h 9 3) (h p 4)))
         ((t (8 9 1) (9 8 2)) (t (h p 3) (h p 4)))
         ((t (8 p 1) (9 8 2)) (t (h 9 3) (h p 4)))
         ((t (8 9 1) (9 p 2)) (t (h 8 3) (h p 4)))
         ((t (8 p 1) (9 9 2)) (t (h 8 3) (h p 4)))
         ((t (8 p 1) (9 p 2)) (t (h 8 3) (h 9 4)))
         ((t (8 8 1) (h 9 2)) (t (9 p 3) (h p 4)))
         ((t (8 8 1) (h p 2)) (t (9 9 3) (h p 4)))
         ((t (8 8 1) (h p 2)) (t (9 p 3) (h 9 4)))
         ((t (8 9 1) (h 8 2)) (t (9 p 3) (h p 4)))
         ((t (8 p 1) (h 8 2)) (t (9 9 3) (h p 4)))
         ((t (8 p 1) (h 8 2)) (t (9 p 3) (h 9 4)))
         ((t (8 9 1) (h p 2)) (t (9 8 3) (h p 4)))
         ((t (8 p 1) (h 9 2)) (t (9 8 3) (h p 4)))
         ((t (8 p 1) (h p 2)) (t (9 8 3) (h 9 4)))
         ((t (8 9 1) (h p 2)) (t (9 p 3) (h 8 4)))
         ((t (8 p 1) (h 9 2)) (t (9 p 3) (h 8 4)))
         ((t (8 p 1) (h p 2)) (t (9 9 3) (h 8 4)))))

(filter-h2e-hole-sym '((t (8 8 1) (h p 2)) (t (9 p 3) (h p 4))))

(id-pair-op '(+ + 1))
(id-pair-op '(1 + 1))
(id-pair-op '(+ 2 1))
(id-pair-op '(2 + 1))

(id-amp '(t (+ + 1) (2 1 1)))
(id-ampprod '((t (8 + 1) (+ + 2)) (t (9 9 3) (+ 8 4))) '(8 9 +))
(id-ampprod '((t (8 + 1) (+ + 2)) (t (9 9 3) (+ 8 4))) '(9 8 +))

(id-ampprod '((t (8 8 1) (9 + 2) (+ 9 3))) '(8 9 +))
(id-ampprod '((t (8 + 1) (+ 8 2) (9 9 3))) '(9 8 +))
(id-ampprod '((t (8 + 1) (9 8 2) (+ 9 3))) '(8 9 +))
(id-ampprod '((t (8 9 1) (+ 8 2) (9 + 3))) '(9 8 +))

(id-ampprod '((t (+ 8 1)) (t (8 + 3) (9 9 4))) '(8 9 +))
(id-ampprod '((t (+ 9 1)) (t (8 8 3) (9 + 4))) '(9 8 +))
(id-ampprod '((t (+ 8 1)) (t (8 9 3) (9 + 4))) '(8 9 +))
(id-ampprod '((t (+ 9 1)) (t (8 + 3) (9 8 4))) '(9 8 +))

(id-ampprod '((t (8 8 1) (9 + 2)) (t (+ 9 3) (+ + 4))) '(8 9 +))
(id-ampprod '((t (8 + 1) (9 9 2)) (t (+ 8 3) (+ + 4))) '(9 8 +))
(id-ampprod '((t (8 + 1) (9 8 2)) (t (+ 9 3) (+ + 4))) '(8 9 +))
(id-ampprod '((t (8 9 1) (9 + 2)) (t (+ 8 3) (+ + 4))) '(9 8 +))
(id-ampprod '((t (8 8 1) (+ 9 2)) (t (9 + 3) (+ + 4))) '(8 9 +))
(id-ampprod '((t (8 + 1) (+ + 2)) (t (9 9 3) (+ 8 4))) '(9 8 +))
(id-ampprod '((t (8 8 1) (+ + 2)) (t (9 + 3) (+ 9 4))) '(8 9 +))
(id-ampprod '((t (8 + 1) (+ 8 2)) (t (9 9 3) (+ + 4))) '(9 8 +))
(id-ampprod '((t (8 9 1) (+ 8 2)) (t (9 + 3) (+ + 4))) '(8 9 +))
(id-ampprod '((t (8 + 1) (+ + 2)) (t (9 8 3) (+ 9 4))) '(9 8 +))
(id-ampprod '((t (8 + 1) (+ 9 2)) (t (9 8 3) (+ + 4))) '(8 9 +))
(id-ampprod '((t (8 9 1) (+ + 2)) (t (9 + 3) (+ 8 4))) '(9 8 +))

(remove-h2e-symm-dup '(((t (8 8 1) (9 + 2)) (t (+ 9 3) (+ + 4)))
                       ((t (8 + 1) (9 9 2)) (t (+ 8 3) (+ + 4))))
                     '(8 9 +))
(pass? (remove-h2e-symm-dup
        (contract-h2e-ampprod '(g (- - 8) (- - 9))
                              '((t (+ + 1) (+ + 2) (+ + 3))))
        '(8 9 +))
       '(((t (8 8 1) (9 9 2) (+ + 3))) ((t (8 8 1) (9 + 2) (+ 9 3)))
         ((t (8 9 1) (9 8 2) (+ + 3))) ((t (8 + 1) (9 8 2) (+ 9 3)))))
(pass? (remove-h2e-symm-dup
        (contract-h2e-ampprod '(g (- - 8) (- - 9))
                              '((t (+ + 1) (+ + 2)) (t (+ + 3) (+ + 4))))
        '(8 9 +))
       '(((t (8 8 1) (9 9 2)) (t (+ + 3) (+ + 4)))
         ((t (8 8 1) (9 + 2)) (t (+ 9 3) (+ + 4)))
         ((t (8 9 1) (9 8 2)) (t (+ + 3) (+ + 4)))
         ((t (8 + 1) (9 8 2)) (t (+ 9 3) (+ + 4)))
         ((t (8 + 1) (9 + 2)) (t (+ 8 3) (+ 9 4)))
         ((t (8 8 1) (+ 9 2)) (t (9 + 3) (+ + 4)))
         ((t (8 8 1) (+ + 2)) (t (9 9 3) (+ + 4)))
         ((t (8 8 1) (+ + 2)) (t (9 + 3) (+ 9 4)))
         ((t (8 9 1) (+ 8 2)) (t (9 + 3) (+ + 4)))
         ((t (8 + 1) (+ 8 2)) (t (9 + 3) (+ 9 4)))
         ((t (8 9 1) (+ + 2)) (t (9 8 3) (+ + 4)))
         ((t (8 + 1) (+ 9 2)) (t (9 8 3) (+ + 4)))
         ((t (8 + 1) (+ 9 2)) (t (9 + 3) (+ 8 4)))))
(remove-h2e-symm-dup
       '(((t (8 8 1) (9 9 2)) (t (h p 3) (h p 4)))
         ((t (8 p 1) (9 9 2)) (t (h 8 3) (h p 4)))
         ((t (8 p 1) (9 p 2)) (t (h 8 3) (h 9 4)))
         ((t (8 8 1) (h 9 2)) (t (9 p 3) (h p 4)))
         ((t (8 8 1) (h p 2)) (t (9 9 3) (h p 4)))
         ((t (8 8 1) (h p 2)) (t (9 p 3) (h 9 4)))
         ((t (8 9 1) (h 8 2)) (t (9 p 3) (h p 4)))
         ((t (8 p 1) (h 8 2)) (t (9 9 3) (h p 4)))
         ((t (8 p 1) (h 8 2)) (t (9 p 3) (h 9 4)))
         ((t (8 8 1) (h 9 2)) (t (9 p 3) (h p 4))))
  '(8 9 h p))


;;;; vim: ft=lisp
