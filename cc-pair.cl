;;; -*- Mode: Common-Lisp; -*-
;;;
;;; Description: based on Goldstone diagram

(load "utility.cl")

(defun attach-tag (tag x)
  (cons tag x))
(defmacro tag-of (x)
  `(car ,x))
(defmacro content-of (x)
  `(cdr ,x))
;;; commutator : p q^\dagger + q^\dagger p = \delta_{pq}

;;; type:
;;; h+   ->-|   '(+ ?)
;;; p+   -<-|   '(? +)
;;; h-   |->-   '(- ?)
;;; p-   |-<-   '(? -)
;;; kr   Kronecker delta
;;;
;;; (t_{ijk}^{abc} (i a) (j b) (k c))

(defun op-copy (n op)
  (loop repeat n
       collect op))
(defun make-pair (hole particle)
  (list hole particle))
(defun hole-of (pair)
  (car pair))
(defun particle-of (pair)
  (cadr pair))

; amp == (t pair1 pair2 ...)
; n-excitation amplitude without linking
(defun make-new-amp (n)
  (attach-tag 't (op-copy n '(+ +))))
; t1 = (make-amp '(+) '(+))
; t2 = (make-amp (op-copy 2 '+) (op-copy 2 '+))

;;; contraction of one hole and an amplitude
(defun contract-hole-amp (amp)
  (let ((pairs (replace-once* (lambda (pair)
                                (unless (eql (hole-of pair) 'k)
                                  (make-pair 'k (particle-of pair))))
                              (content-of amp))))
    (if pairs
        (attach-tag 't pairs))))
(defun contract-particle-amp (amp)
  (let ((pairs (replace-once* (lambda (pair)
                                (unless (eql (particle-of pair) 'k)
                                  (make-pair (hole-of pair) 'k)))
                              (content-of amp))))
    (if pairs
        (attach-tag 't pairs))))

;(defun amp-w/o-index (amp)
;  (mapcar #'op-w/o-index (content-of amp)))
(defun contract-hole-ampprod (ampprod)
  (let ((last-amp '()))
    (mapreplace (lambda (amp)
                  (unless (equal last-amp amp)
                    (setq last-amp amp)
                    (contract-hole-amp amp)))
                ampprod)))
(defun contract-particle-ampprod (ampprod)
  (let ((last-amp '()))
    (mapreplace (lambda (amp)
                  (unless (equal last-amp amp)
                    (setq last-amp amp)
                    (contract-particle-amp amp)))
                ampprod)))

;;; reduce a set of pairs
;;; first reduce all holes to avoid sorting
(defun reduce-pairs (hole-func particle-func pairs init-value)
  (reduce particle-func pairs
          :initial-value (reduce hole-func pairs :initial-value init-value)))

(defun contract-ops-ampprods (pairs ampprod-lst)
  (flet ((hole-func (ampprod-lst pair)
           (if (eql (hole-of pair) '-)
               (let ((res (mapcan #'contract-hole-ampprod ampprod-lst)))
                 (if res res ampprod-lst))
               ampprod-lst))
         (particle-func (ampprod-lst pair)
           (if (eql (particle-of pair) '-)
               (let ((res (mapcan #'contract-particle-ampprod ampprod-lst)))
                 (if res res ampprod-lst))
               ampprod-lst)))
    (reduce-pairs #'hole-func #'particle-func pairs ampprod-lst)))

(defun id-pair-op (pair-op &optional (oplist '(k - +)))
  (let ((shift (length oplist))
        (h-id (position (hole-of pair-op) oplist))
        (p-id (position (particle-of pair-op) oplist)))
    (+ (* shift h-id) p-id)))
(defun id-amp (amp &optional (oplist '(k - +)))
  (mapcar (lambda (x) (id-pair-op x oplist))
          (content-of amp)))
(defun list-lt (l1 l2)
  (cond ((null l1) t)
        ((null l2) nil)
        ((eq (car l1) (car l2))
         (list-lt (cdr l1) (cdr l2)))
        (t (< (car l1) (car l2)))))
(defun sort-ampprod (ampprod)
  (sort ampprod
        (lambda (x y)
          (let ((len-x (length x))
                (len-y (length y)))
            (if (eq len-x len-y)
                (list-lt (id-amp x) (id-amp y))
                (< len-x len-y))))))
(defun contract-ops-ampprods-uniq (ops ampprod-lst)
  (remove-duplicates (contract-ops-ampprods ops ampprod-lst)
                     :test #'equal))

(defun connected-amp? (amp)
  (some (lambda (pair)
          (or (eql (hole-of pair) 'k)
              (eql (particle-of pair) 'k)))
        (content-of amp)))
(defun connected-ampprod? (ampprod)
  (every #'connected-amp? ampprod))

(defun contract-h2e-ampprod (h2e ampprod)
  (let ((diagrams (contract-ops-ampprods-uniq (content-of h2e)
                                              (list ampprod))))
    (mapcar (lambda (amps) (cons h2e amps))
            (remove-if-not #'connected-ampprod? diagrams))))

(defparameter *h2e-ops*
  '((h (- +) (+ +))
    (h (+ +) (- +))
    (h (- -) (- +))
    (h (- +) (- -))
    (h (- +) (- +))
    (h (- -) (+ +))
    (h (+ +) (- -))
    (h (- -) (- -))))

(defun gen-amps-list (n-lst)
  (if (null n-lst)
      '()
      (let* ((tnew (make-new-amp (car n-lst)))
             (t1 (list tnew))
             (t2 (cons tnew t1))
             (t3 (cons tnew t2))
             (t4 (cons tnew t3))
             (amps-lst (gen-amps-list (cdr n-lst)))
             (new-lst (mapcan (lambda (tx)
                                (mapcar (lambda (amps) (append tx amps))
                                        amps-lst))
                              (list t1 t2 t3)))
             (mod-lst (remove-if (lambda (ts) (> (length ts) 4))
                                 new-lst)))
        (append (list t1 t2 t3 t4) mod-lst))))

(defun count-tot-lines (symbol ampprod)
  (flet ((count-in-amp (amp)
           (apply #'+ (mapcar (lambda (pair) (count symbol pair))
                              (content-of amp)))))
    (apply #'+ (mapcar #'count-in-amp ampprod))))

(defun count-hole-lines (ampprod)
  (apply #'+ (mapcar (lambda (amp) (length (content-of amp)))
                     ampprod)))

; return nil if not replaced
(defun label-amp-hole (symb idx amp)
  (let ((pairs (replace-once* (lambda (pair)
                                (if (eql (hole-of pair) symb)
                                    (make-pair idx (particle-of pair))))
                              (content-of amp))))
    (if pairs
        (attach-tag (tag-of amp) pairs))))
(defun label-amp-particle (symb idx amp)
  (let ((pairs (replace-once* (lambda (pair)
                                (if (eql (particle-of pair) symb)
                                    (make-pair (hole-of pair) idx)))
                              (content-of amp))))
    (if pairs
        (attach-tag (tag-of amp) pairs))))
;;; if not contracted, return the input ampprod
    (defun label-contract-line-once (label-func idx ampprod)
      (replace-once (lambda (amp) (funcall label-func 'k idx amp))
                    ampprod))

;;; index-the-lines
;;; return a product, sum over the indices which appear twice
(defun label-lines (ampprod)
  (let ((reg 0))
    (flet ((label-hole (ts pair)
             (if (eql (hole-of pair) '-)
                 (let ((idx (incf reg)))
                   (cons (label-amp-hole '- idx (car ts))
                         (label-contract-line-once #'label-amp-hole idx (cdr ts))))
                 ts))
           (label-particle (ts pair)
             (if (eql (particle-of pair) '-)
                 (let ((idx (incf reg)))
                   (cons (label-amp-particle (particle-of pair) idx (car ts))
                         (label-contract-line-once #'label-amp-particle idx (cdr ts))))
                 ts))
           (label-ext-line (amp)
             (let ((pairs (mapcar (lambda (pair)
                                    (let ((h (hole-of pair))
                                          (p (particle-of pair)))
                                      (cond ((and (eql h '+) (eql p '+))
                                             (make-pair (incf reg) (incf reg)))
                                            ((eql h '+) (make-pair (incf reg) p))
                                            ((eql p '+) (make-pair h (incf reg)))
                                            (t pair))))
                                  (content-of amp))))
               (attach-tag (tag-of amp) pairs))))
      (let ((ctred (reduce-pairs #'label-hole #'label-particle
                                 (content-of (car ampprod)) ampprod)))
        (mapcar #'label-ext-line ctred)))))

; todo
(defun count-loops (ampprod))

;(defun gen-amp-diagrams (n-lst)
;  (flet ((ext-lines (op ampprod)
;           (- (count-tot-lines '+ (cons op ampprod)))
;              (count-tot-lines '- (list op))))
;    (let ((amps (gen-amps-list n-lst))
;          (dex-lines (mapcar (lambda (x) (+ x x)) n-lst)))
;      (mapcan (lambda (ampprod)
;                (mapcan (lambda (h2e-op)
;                          (if (member (ext-lines h2e-op ampprod) dex-lines)
;                              (contract-h2e-ampprod h2e-op ampprod)))
;                        *h2e-ops*))
;              amps))))
